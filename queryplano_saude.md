-- =========================================
-- CRIAÇÃO DO BANCO DE DADOS
-- =========================================
CREATE DATABASE plano_saude;

-- =========================================
-- LISTAGEM DE TABELAS EXISTENTES NO SCHEMA PUBLIC
-- (útil para conferir o que já existe antes de alterar)
-- =========================================
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public';

-- =========================================
-- CONTAGENS INICIAIS DAS PRINCIPAIS TABELAS
-- (para verificar a quantidade de registros antes das alterações)
-- =========================================
SELECT count(*) AS total_pessoas FROM pessoa;
SELECT count(*) AS total_pacientes FROM paciente;
SELECT count(*) AS total_medicos FROM medico;
SELECT count(*) AS total_consultas FROM consulta;

-- =========================================
-- VISUALIZAR ESTRUTURA E DADOS ATUAIS DA TABELA PESSOA
-- =========================================
SELECT id, nome, endereco FROM pessoa LIMIT 20;

-- =========================================
-- NORMALIZAÇÃO DO ENDEREÇO: 
-- DEIXAR AS COLUNAS ATÔMICAS (separadas)
-- =========================================
ALTER TABLE pessoa
  ADD COLUMN logradouro varchar(255),
  ADD COLUMN numero varchar(20),
  ADD COLUMN complemento varchar(100),
  ADD COLUMN bairro varchar(100),
  ADD COLUMN cidade varchar(100),
  ADD COLUMN uf char(2),
  ADD COLUMN cep varchar(9);

-- =========================================
-- MIGRAÇÃO SIMPLES DE DADOS DE ENDEREÇO ANTIGO
-- (divide a coluna "endereco" antiga em logradouro e número)
-- =========================================
UPDATE pessoa
SET logradouro = split_part(endereco, ',', 1),
    numero = trim(split_part(endereco, ',', 2));

-- =========================================
-- REMOÇÃO DA COLUNA ANTIGA DE ENDEREÇO
-- (já que as informações foram decompostas)
-- =========================================
ALTER TABLE pessoa DROP COLUMN endereco;

-- =========================================
-- CONFERÊNCIA DO RESULTADO DA MIGRAÇÃO DE ENDEREÇOS
-- =========================================
SELECT nome, logradouro, numero, cidade, uf, cep FROM pessoa LIMIT 15;

-- =========================================
-- CRIAÇÃO DA TABELA DE ESPECIALIDADES MÉDICAS
-- =========================================
CREATE TABLE especialidade (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome varchar(100) NOT NULL UNIQUE
);

-- =========================================
-- POPULAR A TABELA DE ESPECIALIDADE COM OS VALORES EXISTENTES
-- NA COLUNA "especialidade" DA TABELA MEDICO
-- =========================================
INSERT INTO especialidade (nome)
SELECT DISTINCT especialidade 
FROM medico 
WHERE especialidade IS NOT NULL;

-- =========================================
-- ADICIONAR A COLUNA DE REFERÊNCIA (CHAVE ESTRANGEIRA)
-- NA TABELA MEDICO
-- =========================================
ALTER TABLE medico ADD COLUMN especialidade_id int;

-- =========================================
-- ATUALIZAR A TABELA MÉDICO COM OS IDs DAS ESPECIALIDADES
-- (substitui o texto pelo id da tabela "especialidade")
-- =========================================
UPDATE medico m
SET especialidade_id = (
  SELECT id FROM especialidade e WHERE e.nome = m.especialidade
);

-- =========================================
-- CRIAR A CHAVE ESTRANGEIRA ENTRE MÉDICO E ESPECIALIDADE
-- =========================================
ALTER TABLE medico
  ADD CONSTRAINT fk_medico_especialidade FOREIGN KEY (especialidade_id)
  REFERENCES especialidade(id);

-- =========================================
-- REMOVER A COLUNA ANTIGA DE ESPECIALIDADE (texto)
-- =========================================
ALTER TABLE medico DROP COLUMN especialidade;

-- =========================================
-- VALIDAÇÃO DA MIGRAÇÃO (JOIN ENTRE AS TABELAS)
-- =========================================
SELECT m.pessoa_id, p.nome, e.nome AS especialidade
FROM medico m
JOIN pessoa p ON m.pessoa_id = p.id
JOIN especialidade e ON m.especialidade_id = e.id;

-- =========================================
-- LIMPEZA DE CPF: REMOVER PONTOS E TRAÇOS
-- =========================================
UPDATE pessoa
SET cpf = regexp_replace(cpf, '[^0-9]', '', 'g');

-- =========================================
-- IDENTIFICAR CPFs COM TAMANHO INCORRETO
-- =========================================
SELECT id, cpf FROM pessoa WHERE length(cpf) != 11;

-- =========================================
-- ALTERAR TIPO DE DADO DO CPF PARA CHAR(11)
-- E GARANTIR PREENCHIMENTO COM ZEROS SE PRECISO
-- =========================================
ALTER TABLE pessoa ALTER COLUMN cpf TYPE char(11)
  USING lpad(regexp_replace(cpf, '[^0-9]', '', 'g'), 11, '0');

-- =========================================
-- ADICIONAR CONSTRAINT PARA GARANTIR FORMATO DE CPF VÁLIDO
-- =========================================
ALTER TABLE pessoa ADD CONSTRAINT chk_cpf_formato CHECK (cpf ~ '^[0-9]{11}$');

-- =========================================
-- LIMPEZA DE TELEFONES (REMOVER QUALQUER CARACTERE NÃO NUMÉRICO)
-- =========================================
UPDATE pessoa SET telefone = regexp_replace(telefone, '[^0-9]', '', 'g');

-- =========================================
-- AJUSTAR TIPO DE TELEFONE E GARANTIR SOMENTE NÚMEROS
-- =========================================
ALTER TABLE pessoa ALTER COLUMN telefone TYPE varchar(15)
  USING regexp_replace(telefone, '[^0-9]', '', 'g');

-- =========================================
-- VERIFICAR RESULTADO DE LIMPEZA DE CPF E TELEFONE
-- =========================================
SELECT id, nome, cpf, telefone FROM pessoa;

-- =========================================
-- IDENTIFICAR EMAILS DUPLICADOS
-- =========================================
SELECT email, count(*) 
FROM pessoa 
GROUP BY email 
HAVING count(*) > 1;

-- =========================================
-- VERIFICAR EMAILS INVÁLIDOS (QUE NÃO BATEM COM O PADRÃO)
-- =========================================
SELECT * FROM pessoa
WHERE email !~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';

-- =========================================
-- ADICIONAR RESTRIÇÕES PARA EMAIL:
-- - UNICIDADE
-- - FORMATO VÁLIDO
-- =========================================
ALTER TABLE pessoa ADD CONSTRAINT uq_pessoa_email UNIQUE (email);
ALTER TABLE pessoa ADD CONSTRAINT chk_email_formato
  CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- =========================================
-- IMPEDIR QUE UM MÉDICO TENHA DUAS CONSULTAS NO MESMO HORÁRIO
-- (garante que o mesmo médico não se duplique no mesmo dia/hora)
-- =========================================
ALTER TABLE consulta
ADD CONSTRAINT uq_medico_agendamento UNIQUE (medico_id, data_consulta);

-- =========================================
-- TESTE DA RESTRIÇÃO ACIMA (DEVE FALHAR SE DUPLICAR)
-- =========================================
INSERT INTO consulta (paciente_id, medico_id, data_consulta, observacoes)
VALUES (1, 16, '2025-01-10 09:00', 'Teste duplicado');

-- =========================================
-- RELATÓRIO DE MÉDICOS SEM CONSULTAS (USANDO LEFT JOIN)
-- =========================================
SELECT p.nome AS medico, m.crm
FROM medico m
JOIN pessoa p ON m.pessoa_id = p.id
LEFT JOIN consulta c ON m.pessoa_id = c.medico_id
WHERE c.id IS NULL;

-- =========================================
-- MESMO RELATÓRIO, MAS USANDO NOT EXISTS
-- =========================================
SELECT p.nome AS medico, m.crm
FROM medico m
JOIN pessoa p ON m.pessoa_id = p.id
WHERE NOT EXISTS (
  SELECT 1 FROM consulta c WHERE c.medico_id = m.pessoa_id
);

-- =========================================
-- PACIENTES SEM CONSULTAS (LEFT JOIN)
-- =========================================
SELECT p.nome AS paciente, pa.numero_cartao
FROM paciente pa
JOIN pessoa p ON pa.pessoa_id = p.id
LEFT JOIN consulta c ON pa.pessoa_id = c.paciente_id
WHERE c.id IS NULL;

-- =========================================
-- APLICAR REGRAS DE OBRIGATORIEDADE E UNICIDADE
-- =========================================

-- CPF e DATA DE NASCIMENTO OBRIGATÓRIOS NA PESSOA
ALTER TABLE pessoa ALTER COLUMN cpf SET NOT NULL;
ALTER TABLE pessoa ALTER COLUMN data_nascimento SET NOT NULL;

-- PACIENTE: número do cartão obrigatório e único
ALTER TABLE paciente ALTER COLUMN numero_cartao SET NOT NULL;
ALTER TABLE paciente ADD CONSTRAINT uq_paciente_numero_cartao UNIQUE (numero_cartao);

-- MÉDICO: CRM obrigatório e único
ALTER TABLE medico ALTER COLUMN crm SET NOT NULL;
ALTER TABLE medico ADD CONSTRAINT uq_medico_crm UNIQUE (crm);

-- =========================================
-- CONTAGENS FINAIS PARA CONFERIR INTEGRIDADE
-- =========================================
SELECT count(*) FROM pessoa;
SELECT count(*) FROM paciente;
SELECT count(*) FROM medico;
SELECT count(*) FROM consulta;

-- =========================================
-- VERIFICAÇÕES FINAIS DE INTEGRIDADE
-- =========================================
SELECT * FROM pessoa WHERE cpf IS NULL OR cpf !~ '^[0-9]{11}$';
SELECT * FROM medico WHERE crm IS NULL;

-- =========================================
-- TESTE FINAL DE DUPLICIDADE DE CONSULTA (DEVE GERAR ERRO)
-- =========================================
INSERT INTO consulta (paciente_id, medico_id, data_consulta, observacoes)
VALUES (2, 16, '2025-01-10 09:00', 'Teste de duplicidade');
